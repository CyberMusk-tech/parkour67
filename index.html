<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Parkour Game - Full Version</title>
<style>
  body { margin:0; overflow:hidden; background:#1e1e1e; }
  canvas { display:block; }
  #instructions {
    position:absolute; top:10px; left:10px; color:white;
    font-family:sans-serif; font-size:16px;
    background:rgba(0,0,0,0.5); padding:8px; border-radius:5px;
  }
  #winMessage {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    color:#00ff00; font-size:32px; font-family:sans-serif; display:none;
  }
  #startButton {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    padding:20px 40px; font-size:24px; cursor:pointer; border:none;
    border-radius:10px; background:#007bff; color:white;
  }
</style>
</head>
<body>
<div id="instructions">
  W/A/S/D = move, Space = jump, Mouse = look around
</div>
<div id="winMessage">ðŸŽ‰ You Finished! ðŸŽ‰</div>
<button id="startButton">Click to Start</button>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/PointerLockControls.js"></script>
<script>
let camera, scene, renderer, controls;
let player, velocityY=0;
const gravity=-0.02;
const platforms=[], hazards=[];
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
let canJump=false;
let finished=false;

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1e1e1e);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,1000);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff,1);
  light.position.set(5,10,7);
  scene.add(light);

  // Player
  player = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xff0000}));
  player.position.set(0,0.5,0);
  scene.add(player);

  // Create platform
  function createPlatform(x,y,z,w,d,moving=false,speed=0,vertical=false){
    const plat = new THREE.Mesh(new THREE.BoxGeometry(w,0.5,d), new THREE.MeshStandardMaterial({color:moving?0xffaa00:0x00ff00}));
    plat.position.set(x,y,z);
    plat.userData={moving, speed, dir:1, vertical};
    scene.add(plat);
    platforms.push(plat);
  }

  // Create hazard
  function createHazard(x,y,z,w,d){
    const hazard = new THREE.Mesh(new THREE.BoxGeometry(w,0.5,d), new THREE.MeshStandardMaterial({color:0xff0000}));
    hazard.position.set(x,y,z);
    scene.add(hazard);
    hazards.push(hazard);
  }

  // Platforms
  createPlatform(0,0,0,5,5);
  createPlatform(5,0,-5,5,5,true,0.05);
  createPlatform(10,1,-10,5,5);
  createPlatform(15,2,-15,5,5,true,0.08,true);
  createPlatform(20,2,-20,5,5);
  createPlatform(25,1,-25,5,5,true,0.1);
  createPlatform(30,1,-30,5,5);
  createPlatform(35,0,-35,5,5);

  // Hazards
  createHazard(12,1.25,-12,5,5);
  createHazard(28,1.25,-28,5,5);

  // Finish
  const finish = new THREE.Mesh(new THREE.BoxGeometry(3,0.5,3), new THREE.MeshStandardMaterial({color:0x0000ff}));
  finish.position.set(38,0.5,-38);
  finish.name="finish";
  scene.add(finish);

  // Controls
  controls = new THREE.PointerLockControls(camera, document.body);
  controls.getObject().position.set(player.position.x,player.position.y+1.5,player.position.z);

  // START BUTTON FIXED
  document.getElementById('startButton').addEventListener('click', ()=>{
    const btn = document.getElementById('startButton');
    btn.style.display='none';  // hide it
    btn.remove();               // remove so click can register
    controls.lock();            // now pointer lock works
  });

  // Keyboard
  document.addEventListener('keydown', e=>{
    switch(e.code){
      case 'KeyW': moveForward=true; break;
      case 'KeyS': moveBackward=true; break;
      case 'KeyA': moveLeft=true; break;
      case 'KeyD': moveRight=true; break;
      case 'Space': if(canJump){ velocityY=0.3; canJump=false; } break;
    }
  });
  document.addEventListener('keyup', e=>{
    switch(e.code){
      case 'KeyW': moveForward=false; break;
      case 'KeyS': moveBackward=false; break;
      case 'KeyA': moveLeft=false; break;
      case 'KeyD': moveRight=false; break;
    }
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function animate(){
  requestAnimationFrame(animate);
  const speed = 0.2;
  let forward=new THREE.Vector3();
  controls.getDirection(forward);

  if(moveForward) player.position.add(forward.clone().multiplyScalar(speed));
  if(moveBackward) player.position.add(forward.clone().multiplyScalar(-speed));
  if(moveLeft) player.position.x -= speed;
  if(moveRight) player.position.x += speed;

  // Gravity
  velocityY += gravity;
  player.position.y += velocityY;

  // Platforms
  let onPlat=false;
  platforms.forEach(p=>{
    if(p.userData.moving){
      if(p.userData.vertical){
        p.position.y += p.userData.speed*p.userData.dir;
        if(p.position.y>3 || p.position.y<0) p.userData.dir*=-1;
      } else {
        p.position.x += p.userData.speed*p.userData.dir;
        if(p.position.x>40 || p.position.x<5) p.userData.dir*=-1;
      }
    }
    if(player.position.x>p.position.x-2.5 && player.position.x<p.position.x+2.5 &&
       player.position.z>p.position.z-2.5 && player.position.z<p.position.z+2.5 &&
       player.position.y>p.position.y && player.position.y<p.position.y+0.5){
         onPlat=true; velocityY=0; canJump=true;
         player.position.y=p.position.y+0.5;
       }
  });

  // Hazards
  hazards.forEach(h=>{
    if(player.position.x>h.position.x-2.5 && player.position.x<h.position.x+2.5 &&
       player.position.z>h.position.z-2.5 && player.position.z<h.position.z+2.5 &&
       player.position.y>h.position.y && player.position.y<h.position.y+1){
         player.position.set(0,0.5,0);
         velocityY=0;
       }
  });

  if(!onPlat && player.position.y<0){ player.position.y=0.5; velocityY=0; canJump=true; }

  // Finish
  const finish = scene.getObjectByName('finish');
  if(finish && !finished && player.position.distanceTo(finish.position)<1.5){
    finished=true;
    document.getElementById('winMessage').style.display='block';
  }

  // Sync camera
  controls.getObject().position.set(player.position.x,player.position.y+1.5,player.position.z);

  renderer.render(scene,camera);
}

init();
animate();
</script>
</body>
</html>
